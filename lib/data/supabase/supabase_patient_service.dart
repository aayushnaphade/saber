import 'package:logging/logging.dart';
import 'package:saber/data/models/patient.dart';
import 'package:saber/data/supabase/supabase_client.dart';

/// Service for managing patient data in Supabase
class SupabasePatientService {
  static final log = Logger('SupabasePatientService');

  /// Get all patients for the current doctor
  static Future<List<Patient>> getAllPatients() async {
    try {
      log.info('Fetching all patients');

      final response = await supabase
          .from('patients')
          .select()
          .order('created_at', ascending: false);

      final patients = (response as List)
          .map((json) => Patient.fromJson(json as Map<String, dynamic>))
          .toList();

      log.info('Fetched ${patients.length} patients');
      return patients;
    } catch (e) {
      log.severe('Failed to fetch patients', e);
      rethrow;
    }
  }

  /// Get active patients only
  static Future<List<Patient>> getActivePatients() async {
    try {
      log.info('Fetching active patients');

      final response = await supabase
          .from('patients')
          .select()
          .eq('is_active', true)
          .order('created_at', ascending: false);

      final patients = (response as List)
          .map((json) => Patient.fromJson(json as Map<String, dynamic>))
          .toList();

      log.info('Fetched ${patients.length} active patients');
      return patients;
    } catch (e) {
      log.severe('Failed to fetch active patients', e);
      rethrow;
    }
  }

  /// Get patients in waiting queue
  static Future<List<Patient>> getWaitingPatients() async {
    try {
      log.info('Fetching waiting patients');

      final response = await supabase
          .from('patients')
          .select()
          .eq('status', 'waiting')
          .order('created_at', ascending: true); // FIFO order

      final patients = (response as List)
          .map((json) => Patient.fromJson(json as Map<String, dynamic>))
          .toList();

      log.info('Fetched ${patients.length} waiting patients');
      return patients;
    } catch (e) {
      log.severe('Failed to fetch waiting patients', e);
      rethrow;
    }
  }

  /// Get a single patient by ID
  static Future<Patient?> getPatient(String patientId) async {
    try {
      log.info('Fetching patient: $patientId');

      final response = await supabase
          .from('patients')
          .select()
          .eq('id', patientId)
          .maybeSingle();

      if (response == null) {
        log.info('Patient not found: $patientId');
        return null;
      }

      final patient = Patient.fromJson(response as Map<String, dynamic>);
      log.info('Fetched patient: ${patient.fullName}');
      return patient;
    } catch (e) {
      log.severe('Failed to fetch patient: $patientId', e);
      rethrow;
    }
  }

  /// Search patients by name
  static Future<List<Patient>> searchPatients(String query) async {
    try {
      log.info('Searching patients with query: $query');

      final response = await supabase
          .from('patients')
          .select()
          .ilike('full_name', '%$query%')
          .order('created_at', ascending: false);

      final patients = (response as List)
          .map((json) => Patient.fromJson(json as Map<String, dynamic>))
          .toList();

      log.info('Found ${patients.length} patients matching "$query"');
      return patients;
    } catch (e) {
      log.severe('Failed to search patients', e);
      rethrow;
    }
  }

  /// Create a new patient
  static Future<Patient> createPatient({
    required String fullName,
    int? age,
    String? gender,
    String? phoneNumber,
    String? email,
    Map<String, dynamic>? medicalHistory,
  }) async {
    try {
      log.info('Creating patient: $fullName');

      final currentUserId = supabase.auth.currentUser?.id;
      if (currentUserId == null) {
        throw Exception('User not authenticated');
      }

      final patient = Patient(
        id: '', // Will be generated by DB
        createdAt: DateTime.now(),
        fullName: fullName,
        age: age,
        gender: gender,
        status: PatientStatus.waiting,
        lastVisit: null,
        doctorId: currentUserId,
        phoneNumber: phoneNumber,
        email: email,
        medicalHistory: medicalHistory,
        isActive: true,
      );

      final response = await supabase
          .from('patients')
          .insert(patient.toInsertJson())
          .select()
          .single();

      final createdPatient = Patient.fromJson(response as Map<String, dynamic>);
      log.info('Created patient: ${createdPatient.id}');
      return createdPatient;
    } catch (e) {
      log.severe('Failed to create patient', e);
      rethrow;
    }
  }

  /// Update patient information
  static Future<Patient> updatePatient(
    String patientId,
    Map<String, dynamic> updates,
  ) async {
    try {
      log.info('Updating patient: $patientId');

      final response = await supabase
          .from('patients')
          .update(updates)
          .eq('id', patientId)
          .select()
          .single();

      final updatedPatient = Patient.fromJson(response as Map<String, dynamic>);
      log.info('Updated patient: ${updatedPatient.id}');
      return updatedPatient;
    } catch (e) {
      log.severe('Failed to update patient: $patientId', e);
      rethrow;
    }
  }

  /// Update patient status
  static Future<Patient> updatePatientStatus(
    String patientId,
    PatientStatus status,
  ) async {
    try {
      log.info('Updating patient status: $patientId -> $status');

      final updates = {
        'status': status.value,
        if (status == PatientStatus.completed)
          'last_visit': DateTime.now().toIso8601String(),
      };

      return await updatePatient(patientId, updates);
    } catch (e) {
      log.severe('Failed to update patient status: $patientId', e);
      rethrow;
    }
  }

  /// Mark patient as inactive (soft delete)
  static Future<void> deactivatePatient(String patientId) async {
    try {
      log.info('Deactivating patient: $patientId');

      await supabase
          .from('patients')
          .update({'is_active': false})
          .eq('id', patientId);

      log.info('Deactivated patient: $patientId');
    } catch (e) {
      log.severe('Failed to deactivate patient: $patientId', e);
      rethrow;
    }
  }

  /// Permanently delete patient (use with caution)
  static Future<void> deletePatient(String patientId) async {
    try {
      log.info('Deleting patient: $patientId');

      await supabase.from('patients').delete().eq('id', patientId);

      log.info('Deleted patient: $patientId');
    } catch (e) {
      log.severe('Failed to delete patient: $patientId', e);
      rethrow;
    }
  }

  /// Watch for real-time changes to patients
  static Stream<List<Patient>> watchPatients() {
    return supabase
        .from('patients')
        .stream(primaryKey: ['id'])
        .order('created_at', ascending: false)
        .map(
          (data) => data
              .map((json) => Patient.fromJson(json as Map<String, dynamic>))
              .toList(),
        );
  }

  /// Watch for real-time changes to waiting queue
  static Stream<List<Patient>> watchWaitingQueue() {
    return supabase
        .from('patients')
        .stream(primaryKey: ['id'])
        .eq('status', 'waiting')
        .order('created_at', ascending: true)
        .map(
          (data) => data
              .map((json) => Patient.fromJson(json as Map<String, dynamic>))
              .toList(),
        );
  }
}
